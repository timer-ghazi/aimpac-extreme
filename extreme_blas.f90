! Generated from extreme.f90
! Contains: DAXPY, DSCAL, DSWAP, DASUM, DDOT, IDAMAX, DGECO, DGEDI, DGEFA, DIVSTR


SUBROUTINE DAXPY(N,DA,DX,INCX,DY,INCY)
   DOUBLE PRECISION DX(1),DY(1),DA
   INTEGER I,INCX,INCY,IXIY,M,MP1,N
   IF(N.LE.0)RETURN
   IF (DA .EQ. 0.0D0) RETURN
   IF(INCX.EQ.1.AND.INCY.EQ.1)GO TO 20
   IX = 1
   IY = 1
   IF(INCX.LT.0)IX = (-N+1)*INCX + 1
   IF(INCY.LT.0)IY = (-N+1)*INCY + 1
   DO 10 I = 1,N
      DY(IY) = DY(IY) + DA*DX(IX)
      IX = IX + INCX
      IY = IY + INCY
10 CONTINUE
   RETURN
20 M = MOD(N,4)
   IF( M .EQ. 0 ) GO TO 40
   DO 30 I = 1,M
      DY(I) = DY(I) + DA*DX(I)
30 CONTINUE
   IF( N .LT. 4 ) RETURN
40 MP1 = M + 1
   DO 50 I = MP1,N,4
      DY(I) = DY(I) + DA*DX(I)
      DY(I + 1) = DY(I + 1) + DA*DX(I + 1)
      DY(I + 2) = DY(I + 2) + DA*DX(I + 2)
      DY(I + 3) = DY(I + 3) + DA*DX(I + 3)
50 CONTINUE
   RETURN
END

SUBROUTINE  DSCAL(N,DA,DX,INCX)
!
!     SCALES A VECTOR BY A CONSTANT.
!     USES UNROLLED LOOPS FOR INCREMENT EQUAL TO ONE.
!     JACK DONGARRA, LINPACK, 3/11/78.
!
   DOUBLE PRECISION DA,DX(1)
   INTEGER I,INCX,M,MP1,N,NINCX
!
   IF(N.LE.0)RETURN
   IF(INCX.EQ.1)GO TO 20
!
!        CODE FOR INCREMENT NOT EQUAL TO 1
!
   NINCX = N*INCX
   DO 10 I = 1,NINCX,INCX
      DX(I) = DA*DX(I)
10 CONTINUE
   RETURN
!
!        CODE FOR INCREMENT EQUAL TO 1
!
!
!        CLEAN-UP LOOP
!
20 M = MOD(N,5)
   IF( M .EQ. 0 ) GO TO 40
   DO 30 I = 1,M
      DX(I) = DA*DX(I)
30 CONTINUE
   IF( N .LT. 5 ) RETURN
40 MP1 = M + 1
   DO 50 I = MP1,N,5
      DX(I) = DA*DX(I)
      DX(I + 1) = DA*DX(I + 1)
      DX(I + 2) = DA*DX(I + 2)
      DX(I + 3) = DA*DX(I + 3)
      DX(I + 4) = DA*DX(I + 4)
50 CONTINUE
   RETURN
END

SUBROUTINE  DSWAP (N,DX,INCX,DY,INCY)
!
!     INTERCHANGES TWO VECTORS.
!     USES UNROLLED LOOPS FOR INCREMENTS EQUAL ONE.
!     JACK DONGARRA, LINPACK, 3/11/78.
!
   DOUBLE PRECISION DX(1),DY(1),DTEMP
   INTEGER I,INCX,INCY,IX,IY,M,MP1,N
!
   IF(N.LE.0)RETURN
   IF(INCX.EQ.1.AND.INCY.EQ.1)GO TO 20
!
!       CODE FOR UNEQUAL INCREMENTS OR EQUAL INCREMENTS NOT EQUAL
!         TO 1
!
   IX = 1
   IY = 1
   IF(INCX.LT.0)IX = (-N+1)*INCX + 1
   IF(INCY.LT.0)IY = (-N+1)*INCY + 1
   DO 10 I = 1,N
      DTEMP = DX(IX)
      DX(IX) = DY(IY)
      DY(IY) = DTEMP
      IX = IX + INCX
      IY = IY + INCY
10 CONTINUE
   RETURN
!
!       CODE FOR BOTH INCREMENTS EQUAL TO 1
!
!
!       CLEAN-UP LOOP
!
20 M = MOD(N,3)
   IF( M .EQ. 0 ) GO TO 40
   DO 30 I = 1,M
      DTEMP = DX(I)
      DX(I) = DY(I)
      DY(I) = DTEMP
30 CONTINUE
   IF( N .LT. 3 ) RETURN
40 MP1 = M + 1
   DO 50 I = MP1,N,3
      DTEMP = DX(I)
      DX(I) = DY(I)
      DY(I) = DTEMP
      DTEMP = DX(I + 1)
      DX(I + 1) = DY(I + 1)
      DY(I + 1) = DTEMP
      DTEMP = DX(I + 2)
      DX(I + 2) = DY(I + 2)
      DY(I + 2) = DTEMP
50 CONTINUE
   RETURN
END

DOUBLE PRECISION FUNCTION DASUM(N,DX,INCX)
!
!     TAKES THE SUM OF THE ABSOLUTE VALUES.
!     JACK DONGARRA, LINPACK, 3/11/78.
!
   DOUBLE PRECISION DX(1),DTEMP
   INTEGER I,INCX,M,MP1,N,NINCX
!
   DASUM = 0.0D0
   DTEMP = 0.0D0
   IF(N.LE.0)RETURN
   IF(INCX.EQ.1)GO TO 20
!
!        CODE FOR INCREMENT NOT EQUAL TO 1
!
   NINCX = N*INCX
   DO 10 I = 1,NINCX,INCX
      DTEMP = DTEMP + DABS(DX(I))
10 CONTINUE
   DASUM = DTEMP
   RETURN
!
!        CODE FOR INCREMENT EQUAL TO 1
!
!
!        CLEAN-UP LOOP
!
20 M = MOD(N,6)
   IF( M .EQ. 0 ) GO TO 40
   DO 30 I = 1,M
      DTEMP = DTEMP + DABS(DX(I))
30 CONTINUE
   IF( N .LT. 6 ) GO TO 60
40 MP1 = M + 1
   DO 50 I = MP1,N,6
      DTEMP = DTEMP + DABS(DX(I)) + DABS(DX(I + 1)) + DABS(DX(I + 2))&
      &+ DABS(DX(I + 3)) + DABS(DX(I + 4)) + DABS(DX(I + 5))
50 CONTINUE
60 DASUM = DTEMP
   RETURN
END

DOUBLE PRECISION FUNCTION DDOT(N,DX,INCX,DY,INCY)
!
!     FORMS THE DOT PRODUCT OF TWO VECTORS.
!     USES UNROLLED LOOPS FOR INCREMENTS EQUAL TO ONE.
!     JACK DONGARRA, LINPACK, 3/11/78.
!
   DOUBLE PRECISION DX(1),DY(1),DTEMP
   INTEGER I,INCX,INCY,IX,IY,M,MP1,N
!
   DDOT = 0.0D0
   DTEMP = 0.0D0
   IF(N.LE.0)RETURN
   IF(INCX.EQ.1.AND.INCY.EQ.1)GO TO 20
!
!        CODE FOR UNEQUAL INCREMENTS OR EQUAL INCREMENTS
!          NOT EQUAL TO 1
!
   IX = 1
   IY = 1
   IF(INCX.LT.0)IX = (-N+1)*INCX + 1
   IF(INCY.LT.0)IY = (-N+1)*INCY + 1
   DO 10 I = 1,N
      DTEMP = DTEMP + DX(IX)*DY(IY)
      IX = IX + INCX
      IY = IY + INCY
10 CONTINUE
   DDOT = DTEMP
   RETURN
!
!        CODE FOR BOTH INCREMENTS EQUAL TO 1
!
!
!        CLEAN-UP LOOP
!
20 M = MOD(N,5)
   IF( M .EQ. 0 ) GO TO 40
   DO 30 I = 1,M
      DTEMP = DTEMP + DX(I)*DY(I)
30 CONTINUE
   IF( N .LT. 5 ) GO TO 60
40 MP1 = M + 1
   DO 50 I = MP1,N,5
      DTEMP = DTEMP + DX(I)*DY(I) + DX(I + 1)*DY(I + 1) +&
      &DX(I + 2)*DY(I + 2) + DX(I + 3)*DY(I + 3) + DX(I + 4)*DY(I + 4)
50 CONTINUE
60 DDOT = DTEMP
   RETURN
END

INTEGER FUNCTION IDAMAX(N,DX,INCX)
   DOUBLE PRECISION DX(1),DMAX
   INTEGER I,INCX,IX,N
   IDAMAX = 0
   IF( N .LT. 1 ) RETURN
   IDAMAX = 1
   IF(N.EQ.1)RETURN
   IF(INCX.EQ.1)GO TO 20
   IX = 1
   DMAX = DABS(DX(1))
   IX = IX + INCX
   DO 10 I = 2,N
      IF(DABS(DX(IX)).LE.DMAX) GO TO 5
      IDAMAX = I
      DMAX = DABS(DX(IX))
5     IX = IX + INCX
10 CONTINUE
   RETURN
20 DMAX = DABS(DX(1))
   DO 30 I = 2,N
      IF(DABS(DX(I)).LE.DMAX) GO TO 30
      IDAMAX = I
      DMAX = DABS(DX(I))
30 CONTINUE
   RETURN
END

SUBROUTINE DGECO(A,LDA,N,IPVT,RCOND,Z)
   INTEGER LDA,N,IPVT(1)
   DOUBLE PRECISION A(LDA,1),Z(1)
   DOUBLE PRECISION RCOND
!
!     DGECO FACTORS A DOUBLE PRECISION MATRIX BY GAUSSIAN ELIMINATION
!     AND ESTIMATES THE CONDITION OF THE MATRIX.
!
!     IF  RCOND  IS NOT NEEDED, DGEFA IS SLIGHTLY FASTER.
!     TO SOLVE  A*X = B , FOLLOW DGECO BY DGESL.
!     TO COMPUTE  INVERSE(A)*C , FOLLOW DGECO BY DGESL.
!     TO COMPUTE  DETERMINANT(A) , FOLLOW DGECO BY DGEDI.
!     TO COMPUTE  INVERSE(A) , FOLLOW DGECO BY DGEDI.
!
!     ON ENTRY
!
!        A       DOUBLE PRECISION(LDA, N)
!                THE MATRIX TO BE FACTORED.
!
!        LDA     INTEGER
!                THE LEADING DIMENSION OF THE ARRAY  A .
!
!        N       INTEGER
!                THE ORDER OF THE MATRIX  A .
!
!     ON RETURN
!
!        A       AN UPPER TRIANGULAR MATRIX AND THE MULTIPLIERS
!                WHICH WERE USED TO OBTAIN IT.
!                THE FACTORIZATION CAN BE WRITTEN  A = L*U  WHERE
!                L  IS A PRODUCT OF PERMUTATION AND UNIT LOWER
!                TRIANGULAR MATRICES AND  U  IS UPPER TRIANGULAR.
!
!        IPVT    INTEGER(N)
!                AN INTEGER VECTOR OF PIVOT INDICES.
!
!        RCOND   DOUBLE PRECISION
!                AN ESTIMATE OF THE RECIPROCAL CONDITION OF  A .
!                FOR THE SYSTEM  A*X = B , RELATIVE PERTURBATIONS
!                IN  A  AND  B  OF SIZE  EPSILON  MAY CAUSE
!                RELATIVE PERTURBATIONS IN  X  OF SIZE  EPSILON/RCOND .
!                IF  RCOND  IS SO SMALL THAT THE LOGICAL EXPRESSION
!                           1.0 + RCOND .EQ. 1.0
!                IS TRUE, THEN  A  MAY BE SINGULAR TO WORKING
!                PRECISION.  IN PARTICULAR,  RCOND  IS ZERO  IF
!                EXACT SINGULARITY IS DETECTED OR THE ESTIMATE
!                UNDERFLOWS.
!
!        Z       DOUBLE PRECISION(N)
!                A WORK VECTOR WHOSE CONTENTS ARE USUALLY UNIMPORTANT.
!                IF  A  IS CLOSE TO A SINGULAR MATRIX, THEN  Z  IS
!                AN APPROXIMATE NULL VECTOR IN THE SENSE THAT
!                NORM(A*Z) = RCOND*NORM(A)*NORM(Z) .
!
!     LINPACK. THIS VERSION DATED 08/14/78 .
!     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.
!
!     SUBROUTINES AND FUNCTIONS
!
!     LINPACK DGEFA
!     BLAS DAXPY,DDOT,DSCAL,DASUM
!     FORTRAN DABS,DMAX1,DSIGN
!
!     INTERNAL VARIABLES
!
   DOUBLE PRECISION DDOT,EK,T,WK,WKM
   DOUBLE PRECISION ANORM,S,DASUM,SM,YNORM
   INTEGER INFO,J,K,KB,KP1,L
!
!
!     COMPUTE 1-NORM OF A
!
   ANORM = 0.0D0
   DO 10 J = 1, N
      ANORM = DMAX1(ANORM,DASUM(N,A(1,J),1))
10 CONTINUE
!
!     FACTOR
!
   CALL DGEFA(A,LDA,N,IPVT,INFO)
!
!     RCOND = 1/(NORM(A)*(ESTIMATE OF NORM(INVERSE(A)))) .
!     ESTIMATE = NORM(Z)/NORM(Y) WHERE  A*Z = Y  AND  TRANS(A)*Y = E .
!     TRANS(A)  IS THE TRANSPOSE OF A .  THE COMPONENTS OF  E  ARE
!     CHOSEN TO CAUSE MAXIMUM LOCAL GROWTH IN THE ELEMENTS OF W  WHERE
!     TRANS(U)*W = E .  THE VECTORS ARE FREQUENTLY RESCALED TO AVOID
!     OVERFLOW.
!
!     SOLVE TRANS(U)*W = E
!
   EK = 1.0D0
   DO 20 J = 1, N
      Z(J) = 0.0D0
20 CONTINUE
   DO 100 K = 1, N
      IF (Z(K) .NE. 0.0D0) EK = DSIGN(EK,-Z(K))
      IF (DABS(EK-Z(K)) .LE. DABS(A(K,K))) GO TO 30
      S = DABS(A(K,K))/DABS(EK-Z(K))
      CALL DSCAL(N,S,Z,1)
      EK = S*EK
30    CONTINUE
      WK = EK - Z(K)
      WKM = -EK - Z(K)
      S = DABS(WK)
      SM = DABS(WKM)
      IF (A(K,K) .EQ. 0.0D0) GO TO 40
      WK = WK/A(K,K)
      WKM = WKM/A(K,K)
      GO TO 50
40    CONTINUE
      WK = 1.0D0
      WKM = 1.0D0
50    CONTINUE
      KP1 = K + 1
      IF (KP1 .GT. N) GO TO 90
      DO 60 J = KP1, N
         SM = SM + DABS(Z(J)+WKM*A(K,J))
         Z(J) = Z(J) + WK*A(K,J)
         S = S + DABS(Z(J))
60    CONTINUE
      IF (S .GE. SM) GO TO 80
      T = WKM - WK
      WK = WKM
      DO 70 J = KP1, N
         Z(J) = Z(J) + T*A(K,J)
70    CONTINUE
80    CONTINUE
90    CONTINUE
      Z(K) = WK
100 CONTINUE
   S = 1.0D0/DASUM(N,Z,1)
   CALL DSCAL(N,S,Z,1)
!
!     SOLVE TRANS(L)*Y = W
!
   DO 120 KB = 1, N
      K = N + 1 - KB
      IF (K .LT. N) Z(K) = Z(K) + DDOT(N-K,A(K+1,K),1,Z(K+1),1)
      IF (DABS(Z(K)) .LE. 1.0D0) GO TO 110
      S = 1.0D0/DABS(Z(K))
      CALL DSCAL(N,S,Z,1)
110   CONTINUE
      L = IPVT(K)
      T = Z(L)
      Z(L) = Z(K)
      Z(K) = T
120 CONTINUE
   S = 1.0D0/DASUM(N,Z,1)
   CALL DSCAL(N,S,Z,1)
!
   YNORM = 1.0D0
!
!     SOLVE L*V = Y
!
   DO 140 K = 1, N
      L = IPVT(K)
      T = Z(L)
      Z(L) = Z(K)
      Z(K) = T
      IF (K .LT. N) CALL DAXPY(N-K,T,A(K+1,K),1,Z(K+1),1)
      IF (DABS(Z(K)) .LE. 1.0D0) GO TO 130
      S = 1.0D0/DABS(Z(K))
      CALL DSCAL(N,S,Z,1)
      YNORM = S*YNORM
130   CONTINUE
140 CONTINUE
   S = 1.0D0/DASUM(N,Z,1)
   CALL DSCAL(N,S,Z,1)
   YNORM = S*YNORM
!
!     SOLVE  U*Z = V
!
   DO 160 KB = 1, N
      K = N + 1 - KB
      IF (DABS(Z(K)) .LE. DABS(A(K,K))) GO TO 150
      S = DABS(A(K,K))/DABS(Z(K))
      CALL DSCAL(N,S,Z,1)
      YNORM = S*YNORM
150   CONTINUE
      IF (A(K,K) .NE. 0.0D0) Z(K) = Z(K)/A(K,K)
      IF (A(K,K) .EQ. 0.0D0) Z(K) = 1.0D0
      T = -Z(K)
      CALL DAXPY(K-1,T,A(1,K),1,Z(1),1)
160 CONTINUE
!     MAKE ZNORM = 1.0
   S = 1.0D0/DASUM(N,Z,1)
   CALL DSCAL(N,S,Z,1)
   YNORM = S*YNORM
!
   IF (ANORM .NE. 0.0D0) RCOND = YNORM/ANORM
   IF (ANORM .EQ. 0.0D0) RCOND = 0.0D0
   RETURN
END

SUBROUTINE DGEDI(A,LDA,N,IPVT,DET,WORK,JOB)
   INTEGER LDA,N,IPVT(1),JOB
   DOUBLE PRECISION A(LDA,1),DET(2),WORK(1)
!
!     DGEDI COMPUTES THE DETERMINANT AND INVERSE OF A MATRIX
!     USING THE FACTORS COMPUTED BY DGECO OR DGEFA.
!
!     ON ENTRY
!
!        A       DOUBLE PRECISION(LDA, N)
!                THE OUTPUT FROM DGECO OR DGEFA.
!
!        LDA     INTEGER
!                THE LEADING DIMENSION OF THE ARRAY  A .
!
!        N       INTEGER
!                THE ORDER OF THE MATRIX  A .
!
!        IPVT    INTEGER(N)
!                THE PIVOT VECTOR FROM DGECO OR DGEFA.
!
!        WORK    DOUBLE PRECISION(N)
!                WORK VECTOR.  CONTENTS DESTROYED.
!
!        JOB     INTEGER
!                = 11   BOTH DETERMINANT AND INVERSE.
!                = 01   INVERSE ONLY.
!                = 10   DETERMINANT ONLY.
!
!     ON RETURN
!
!        A       INVERSE OF ORIGINAL MATRIX IF REQUESTED.
!                OTHERWISE UNCHANGED.
!
!        DET     DOUBLE PRECISION(2)
!                DETERMINANT OF ORIGINAL MATRIX IF REQUESTED.
!                OTHERWISE NOT REFERENCED.
!                DETERMINANT = DET(1) * 10.0**DET(2)
!                WITH  1.0 .LE. DABS(DET(1)) .LT. 10.0
!                OR  DET(1) .EQ. 0.0 .
!
!     ERROR CONDITION
!
!        A DIVISION BY ZERO WILL OCCUR IF THE INPUT FACTOR CONTAINS
!        A ZERO ON THE DIAGONAL AND THE INVERSE IS REQUESTED.
!        IT WILL NOT OCCUR IF THE SUBROUTINES ARE CALLED CORRECTLY
!        AND IF DGECO HAS SET RCOND .GT. 0.0 OR DGEFA HAS SET
!        INFO .EQ. 0 .
!
!     LINPACK. THIS VERSION DATED 08/14/78 .
!     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.
!
!     SUBROUTINES AND FUNCTIONS
!
!     BLAS DAXPY,DSCAL,DSWAP
!     FORTRAN DABS,MOD
!
!     INTERNAL VARIABLES
!
   DOUBLE PRECISION T
   DOUBLE PRECISION TEN
   INTEGER I,J,K,KB,KP1,L,NM1
!
!
!     COMPUTE DETERMINANT
!
   IF (JOB/10 .EQ. 0) GO TO 70
   DET(1) = 1.0D0
   DET(2) = 0.0D0
   TEN = 10.0D0
   DO 50 I = 1, N
      IF (IPVT(I) .NE. I) DET(1) = -DET(1)
      DET(1) = A(I,I)*DET(1)
!        ...EXIT
      IF (DET(1) .EQ. 0.0D0) GO TO 60
10    IF (DABS(DET(1)) .GE. 1.0D0) GO TO 20
      DET(1) = TEN*DET(1)
      DET(2) = DET(2) - 1.0D0
      GO TO 10
20    CONTINUE
30    IF (DABS(DET(1)) .LT. TEN) GO TO 40
      DET(1) = DET(1)/TEN
      DET(2) = DET(2) + 1.0D0
      GO TO 30
40    CONTINUE
50 CONTINUE
60 CONTINUE
70 CONTINUE
!
!     COMPUTE INVERSE(U)
!
   IF (MOD(JOB,10) .EQ. 0) GO TO 150
   DO 100 K = 1, N
      A(K,K) = 1.0D0/A(K,K)
      T = -A(K,K)
      CALL DSCAL(K-1,T,A(1,K),1)
      KP1 = K + 1
      IF (N .LT. KP1) GO TO 90
      DO 80 J = KP1, N
         T = A(K,J)
         A(K,J) = 0.0D0
         CALL DAXPY(K,T,A(1,K),1,A(1,J),1)
80    CONTINUE
90    CONTINUE
100 CONTINUE
!
!        FORM INVERSE(U)*INVERSE(L)
!
   NM1 = N - 1
   IF (NM1 .LT. 1) GO TO 140
   DO 130 KB = 1, NM1
      K = N - KB
      KP1 = K + 1
      DO 110 I = KP1, N
         WORK(I) = A(I,K)
         A(I,K) = 0.0D0
110   CONTINUE
      DO 120 J = KP1, N
         T = WORK(J)
         CALL DAXPY(N,T,A(1,J),1,A(1,K),1)
120   CONTINUE
      L = IPVT(K)
      IF (L .NE. K) CALL DSWAP(N,A(1,K),1,A(1,L),1)
130 CONTINUE
140 CONTINUE
150 CONTINUE
   RETURN
END

SUBROUTINE DGEFA(A,LDA,N,IPVT,INFO)
   INTEGER LDA,N,IPVT(1),INFO
   DOUBLE PRECISION A(LDA,1)
!
!     DGEFA FACTORS A DOUBLE PRECISION MATRIX BY GAUSSIAN ELIMINATION.
!
!     DGEFA IS USUALLY CALLED BY DGECO, BUT IT CAN BE CALLED
!     DIRECTLY WITH A SAVING IN TIME IF  RCOND  IS NOT NEEDED.
!     (TIME FOR DGECO) = (1 + 9/N)*(TIME FOR DGEFA) .
!
!     ON ENTRY
!
!        A       DOUBLE PRECISION(LDA, N)
!                THE MATRIX TO BE FACTORED.
!
!        LDA     INTEGER
!                THE LEADING DIMENSION OF THE ARRAY  A .
!
!        N       INTEGER
!                THE ORDER OF THE MATRIX  A .
!
!     ON RETURN
!
!        A       AN UPPER TRIANGULAR MATRIX AND THE MULTIPLIERS
!                WHICH WERE USED TO OBTAIN IT.
!                THE FACTORIZATION CAN BE WRITTEN  A = L*U  WHERE
!                L  IS A PRODUCT OF PERMUTATION AND UNIT LOWER
!                TRIANGULAR MATRICES AND  U  IS UPPER TRIANGULAR.
!
!        IPVT    INTEGER(N)
!                AN INTEGER VECTOR OF PIVOT INDICES.
!
!        INFO    INTEGER
!                = 0  NORMAL VALUE.
!                = K  IF  U(K,K) .EQ. 0.0 .  THIS IS NOT AN ERROR
!                     CONDITION FOR THIS SUBROUTINE, BUT IT DOES
!                     INDICATE THAT DGESL OR DGEDI WILL DIVIDE BY ZERO
!                     IF CALLED.  USE  RCOND  IN DGECO FOR A RELIABLE
!                     INDICATION OF SINGULARITY.
!
!     LINPACK. THIS VERSION DATED 08/14/78 .
!     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.
!
!     SUBROUTINES AND FUNCTIONS
!
!     BLAS DAXPY,DSCAL,IDAMAX
!
!     INTERNAL VARIABLES
!
   DOUBLE PRECISION T
   INTEGER IDAMAX,J,K,KP1,L,NM1
!
!
!     GAUSSIAN ELIMINATION WITH PARTIAL PIVOTING
!
   INFO = 0
   NM1 = N - 1
   IF (NM1 .LT. 1) GO TO 70
   DO 60 K = 1, NM1
      KP1 = K + 1
!
!        FIND L = PIVOT INDEX
!
      L = IDAMAX(N-K+1,A(K,K),1) + K - 1
      IPVT(K) = L
!
!        ZERO PIVOT IMPLIES THIS COLUMN ALREADY TRIANGULARIZED
!
      IF (A(L,K) .EQ. 0.0D0) GO TO 40
!
!           INTERCHANGE IF NECESSARY
!
      IF (L .EQ. K) GO TO 10
      T = A(L,K)
      A(L,K) = A(K,K)
      A(K,K) = T
10    CONTINUE
!
!           COMPUTE MULTIPLIERS
!
      T = -1.0D0/A(K,K)
      CALL DSCAL(N-K,T,A(K+1,K),1)
!
!           ROW ELIMINATION WITH COLUMN INDEXING
!
      DO 30 J = KP1, N
         T = A(L,J)
         IF (L .EQ. K) GO TO 20
         A(L,J) = A(K,J)
         A(K,J) = T
20       CONTINUE
         CALL DAXPY(N-K,T,A(K+1,K),1,A(K+1,J),1)
30    CONTINUE
      GO TO 50
40    CONTINUE
      INFO = K
50    CONTINUE
60 CONTINUE
70 CONTINUE
   IPVT(N) = N
   IF (A(N,N) .EQ. 0.0D0) INFO = N
   RETURN
END

SUBROUTINE DIVSTR(dsig,dsigm)
!
   IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!
   Parameter(MaxOff=200000)
   COMMON CO(MaxOff),IC(MaxOff),NCENT,NMO,NPRIMS
   COMMON /OFFSET/ ITYPE,ICENT,IMO,IEORB,IE,ICHARG,IXC,IYC,IZC,&
   &IXX, IYY, IZZ,IRR,IR2,IP,IPSI,IGX,IGY,IGZ,IGXX,IGXY,IGXZ,IGYY,&
   &IGYZ,IGZZ,IGXXX,IGXXY,IGXXZ,IGXYY,IGXZZ,IGXYZ,IGYYY,IGYYZ,&
   &IGYZZ,IGZZZ,IGXXXX,IGXXXY,IGXXXZ,IGXXYY,IGXXZZ,IGXYYY,IGXZZZ,&
   &IGXXYZ,IGXYYZ,IGXYZZ,IGYYYY,IGYYYZ,IGYYZZ,IGYZZZ,IGZZZZ,ICOFMx
   DIMENSION dsig(3)
   Save Zero,Pt5
   Data Zero/0.d0/,Pt5/0.5d0/
!
   DO 100 I = 1,3
100 Dsig(I) = Dsig(I)
!
   DO 110 J = 1,NMO
      Temp = -(CO(IGXX+J)+CO(IGYY+J)+CO(IGZZ+J))
      DSig(1) = DSig(1)+CO(IP+J)*(CO(IPSI+J)*(CO(IGXXX+J)+&
      &CO(IGXYY+J)+CO(IGXZZ+J)) + temp*CO(IGX+J))
      DSig(2) = DSig(2)+CO(IP+J)*(CO(IPSI+J)*(CO(IGXXY+J)+&
      &CO(IGYYY+J)+CO(IGYZZ+J)) + temp*CO(IGY+J))
110 DSig(3) = DSig(3)+CO(IP+J)*(CO(IPSI+J)*(CO(IGXXZ+J)+&
   &CO(IGYYZ+J)+CO(IGZZZ+J)) + temp*CO(IGZ+J))
!
   DO 120 I = 1,3
120 Dsig(I) = pt5*Dsig(I)
!
   Dsigm = dsqrt(dsig(1)**2+dsig(2)**2+dsig(3)**2)

   RETURN
END
