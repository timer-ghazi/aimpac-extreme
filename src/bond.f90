module bond
  implicit none
contains
SUBROUTINE ALPHA
!
   IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!
   Parameter (MaxOff=200000,MaxAtm=100)
   COMMON CO(MaxOff),IC(MaxOff),NCENT,NMO,NPRIMS
   COMMON /ANG/ ANGLE(3,MaxAtm,MaxAtm)
   COMMON /OFFSET/ ITYPE,ICENT,IMO,IEORB,IE,ICHARG,IXC,IYC,IZC,&
   &IXX, IYY, IZZ,IRR,IR2,IP,IPSI,IGX,IGY,IGZ,IGXX,IGXY,IGXZ,IGYY,&
   &IGYZ,IGZZ,IGXXX,IGXXY,IGXXZ,IGXYY,IGXZZ,IGXYZ,IGYYY,IGYYZ,&
   &IGYZZ,IGZZZ,IGXXXX,IGXXXY,IGXXXZ,IGXXYY,IGXXZZ,IGXYYY,IGXZZZ,&
   &IGXXYZ,IGXYYZ,IGXYZZ,IGYYYY,IGYYYZ,IGYYZZ,IGYZZZ,IGZZZZ,ICOFMx
   COMMON /UNITS/ INPT, IOUT, IWFN, IWLP
   Save One,ThSxty
   Data One/1.d0/,ThSxty/3.6d2/
1000 FORMAT(' HERE IS A LIST OF BOND PATHS THAT HAVE BEEN TRACED ')
1010 FORMAT(/,' INPUT ATOMS FOR WHICH ANGLE IS DESIRED (EG.1,2,3) ',$)
1020 FORMAT(/,' BOND PATH ANGLE = ',F8.4)
1030 FORMAT(/,' GEOMETRIC BOND ANGLE = ',F8.4)
1040 FORMAT(/,' DEVIATION OF FIRST BOND PATH VECTOR FROM FIRST',&
   &' GEOMETRIC BOND VECTOR   ',F8.4)
1050 FORMAT(/,' DEVIATION OF SECOND BOND PATH VECTOR FROM SECOND',&
   &' GEOMETRIC BOND VECTOR ',F8.4)
1060 FORMAT(/,' GEOMETRIC BOND ANGLE MINUS BOND PATH ANGLE ',F8.4)
1070 FORMAT(/,' WOULD YOU LIKE TO DO ANOTHER COMPARISION ? (0/1) ',$)
1080 FORMAT(/,' COMPARISION FOR ATOMS ',3I4)
!
   Pi=DaCos(-One)
   Degree=thsxty/(Two*Pi)
!
100 WRITE (IOUT,1010)
   READ (INPT,*) I,J,K
   WRITE (IOUT,1080) I,J,K
   WRITE (IWLP,1080) I,J,K
!
!    GET BOND PATH ANGLE
!
   S = ANGLE(1,J,K)*ANGLE(1,J,I) +&
   &ANGLE(2,J,K)*ANGLE(2,J,I) +&
   &ANGLE(3,J,K)*ANGLE(3,J,I)
   BANGLE = (DACOS(S))*Degree
   WRITE (IOUT,1020) BANGLE
   WRITE (IWLP,1020) BANGLE
!
!    USE UNIT VECTORS ALONG THE BONDS TO CALCULATE
!    GEOMETRIC BOND ANGLE
!
   C1 = CO(IXC+I) - CO(IXC+J)
   D1 = CO(IXC+K) - CO(IXC+J)
   C2 = CO(IYC+I) - CO(IYC+J)
   D2 = CO(IYC+K) - CO(IYC+J)
   C3 = CO(IZC+I) - CO(IZC+J)
   D3 = CO(IZC+K) - CO(IZC+J)
   S1 = SQRT(C1**2 + C2**2 + C3**2)
   S2 = SQRT(D1**2 + D2**2 + D3**2)
   C1 = C1/S1
   C2 = C2/S1
   C3 = C3/S1
   D1 = D1/S2
   D2 = D2/S2
   D3 = D3/S2
!
!      GET ANGLES BETWEEN BOND PATHS AND BOND DIRECTIONS
!
   S1 = ANGLE(1,J,I)*C1 + ANGLE(2,J,I)*C2 + ANGLE(3,J,I)*C3
   S2 = ANGLE(1,J,K)*D1 + ANGLE(2,J,K)*D2 + ANGLE(3,J,K)*D3
   S3 = C1*D1 + C2*D2 + C3*D3
   ANGLE1 = (DACOS(S1))*Degree
   ANGLE2 = (DACOS(S2))*Degree
   ANGLE3 = (DACOS(S3))*Degree
   WRITE (IOUT,1030) ANGLE3
   WRITE (IWLP,1030) ANGLE3
   WRITE (IOUT,1040) ANGLE1
   WRITE (IWLP,1040) ANGLE1
   WRITE (IOUT,1050) ANGLE2
   WRITE (IWLP,1050) ANGLE2
!
!    DETERMINE THE DIFFERENCE BETWEEN THE BOND PATH ANGLE AND THE
!    GEOMETRIC BOND ANGLE
!
   DANGLE = ANGLE3 - BANGLE
   WRITE (IOUT,1060) DANGLE
   WRITE (IWLP,1060) DANGLE
!
   WRITE (IOUT,1070)
   READ (INPT,*) IGO
   IF (IGO .EQ. 1) GOTO 100
!
   RETURN
!
!    FORMATS
!
END
Subroutine AZero
!
   Implicit Double Precision (A-H,O-Z)
!
   Common /AFG/ A0,AX,AY,AZ,AXX,AXY,AXZ,AYY,AYZ,AZZ,AXXX,&
   &AXXY,AXXZ,AXYY,AXZZ,AXYZ,AYYY,AYYZ,AYZZ,AZZZ,AXXXX,AXXXY,&
   &AXXXZ,AXXYY,AXXZZ,AXYYY,AXZZZ,AXXYZ,AXYYZ,AXYZZ,AYYYY,&
   &AYYYZ,AYYZZ,AYZZZ,AZZZZ,F0,FX,FY,FZ,FXX,FXY,FXZ,FYY,FYZ,&
   &FZZ,FXXX,FXXY,FXXZ,FXYY,FXZZ,FXYZ,FYYY,FYYZ,FYZZ,FZZZ,&
   &FXXXX,FXXXY,FXXXZ,FXXYY,FXXZZ,FXYYY,FXZZZ,FXXYZ,FXYYZ,&
   &FXYZZ,FYYYY,FYYYZ,FYYZZ,FYZZZ,FZZZZ,G0,GX,GY,GZ,GXX,GXY,&
   &GXZ,GYY,GYZ,GZZ,GXXX,GXXY,GXXZ,GXYY,GXZZ,GXYZ,GYYY,GYYZ,&
   &GYZZ,GZZZ,GXXXX,GXXXY,GXXXZ,GXXYY,GXXZZ,GXYYY,GXZZZ,&
   &GXXYZ,GXYYZ,GXYZZ,GYYYY,GYYYZ,GYYZZ,GYZZZ,GZZZZ
   Save Zero
   Data Zero/0.0d0/
!
   A0=Zero
   AX=Zero
   AY=Zero
   AZ=Zero
   AXX=Zero
   AXY=Zero
   AXZ=Zero
   AYY=Zero
   AYZ=Zero
   AZZ=Zero
   AXXX=Zero
   AXXY=Zero
   AXXZ=Zero
   AXYY=Zero
   AXZZ=Zero
   AXYZ=Zero
   AYYY=Zero
   AYYZ=Zero
   AYZZ=Zero
   AZZZ=Zero
   AXXXX=Zero
   AXXXY=Zero
   AXXXZ=Zero
   AXXYY=Zero
   AXXZZ=Zero
   AXYYY=Zero
   AXZZZ=Zero
   AXXYZ=Zero
   AXYYZ=Zero
   AXYZZ=Zero
   Ayyyy=Zero
   Ayyyz=Zero
   Ayyzz=Zero
   Ayzzz=Zero
   Azzzz=Zero
!
   Return
End
BLOCK DATA
!
   IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!
   COMMON /C2/ EPSD,AB(9,9),AM(9,10)
   COMMON /UNITS/  INPT,IOUT,IWFN,IWLP
   COMMON /OPTIONS/ ICUT,IPrint,Eps,EpsNuc,Dmp,DmpNuc
   DATA INPT /5/, IOUT /6/, IWFN /10/, IWLP /12/, ICUT /20/,&
   &IPrint/0/,Eps/1.d-10/,EpsNuc/1.d-8/,Dmp/0.25d0/,DmpNuc/0.025d0/
   DATA AB/1.D0,1.5D0,1.9166666666667D0,2.2916666666667D0,&
   &2.6402777777778D0,&
   &2.9701388888889D0,3.2857308201058D0,3.5899553571428D0,&
   &3.8848233575837D0,0.D0,&
   &-.5D0,-1.3333333333333D0,-2.4583333333333D0,-3.8527777777778D0,&
   &-5.5020833333333D0,-7.3956349206348D0,-9.5252066798940D0,&
   &-11.884150683421D0,0D0,0D0,.4166666666667D0,1.5416666666667D0,&
   &3.6333333333333D0,6.9319444444444D0,11.6658234126982D0,&
   &18.054538690476D0,26.310842702821D0,0D0,0D0,0D0,-.375D0,&
   &-1.7694444444444D0,-5.0680555555556D0,-11.379894179894D0,&
   &-22.027752976190D0,-38.540361000881D0,0D0,0D0,0D0,0D0,&
   &.3486111111111D0,1.9979166666667D0,6.7317956349205D0,&
   &17.379654431217D0,38.020414462081D0,0D0,0D0,0D0,0D0,0D0,&
   &-.3298611111111D0,-2.2234126984127D0,-8.6121279761903D0,&
   &-25.124736000882D0,0D0,0D0,0D0,0D0,0D0,0D0,.3155919312169D0,&
   &2.4451636904761D0,10.701467702822D0,0D0,0D0,0D0,0D0,0D0,0D0,0D0,&
   &-.3042245370370D0,-2.6631685405644D0,0D0,0D0,0D0,0D0,0D0,0D0,0D0,&
   &0D0,.2948680004409D0/
   DATA AM/.5D0,.4166666666667D0,.375D0,.3486111111111D0,&
   &.3298611111111D0,.3155919312169D0,.3042245370370D0,&
   &.2948680004409D0,.2869754464286D0,.5D0,.6666666666667D0,&
   &.7916666666667D0,.8972222222222D0,.9909722222222D0,&
   &1.0765873015873D0,1.1561590608466D0,1.2310113536155D0,&
   &1.3020443397266D0,0D0,-.0833333333333D0,-.2083333333333D0,&
   &-.3666666666667D0,-.5541666666667D0,-.7682043650794D0,&
   &-1.0069196428571D0,-1.2689026675485D0,-1.55303461199292D0,0D0,0D0,&
   &.0416666666667D0,.1472222222222D0,.3347222222222D0,&
   &.6201058201058D0,1.0179646164021D0,1.5419306657848D0,&
   &2.2049052028218D0,0D0,0D0,0D0,-.0263888888889D0,-.1201388888889D0,&
   &-.3341765873016D0,-.7320353835979D0,&
   &-1.3869929453262D0,-2.3814547508818D0,0D0,0D0,0D0,0D0,.01875D0,&
   &.1043650793651D0,.3430803571429D0,.8670464065255D0,&
   &1.8615082120811D0,0D0,0D0,0D0,0D0,0D0,&
   &-.0142691798942D0,-.0938409391534D0,-.3558239638448D0,&
   &-1.0187985008818D0,0D0,0D0,0D0,0D0,0D0,0D0,&
   &.0113673941799D0,.0862196869489D0,.3703516313933D0,&
   &0D0,0D0,0D0,0D0,0D0,0D0,0D0,-.0093565365961D0,-.0803895227072D0,&
   &0D0,0D0,0D0,0D0,0D0,0D0,0D0,0D0,.0078925540124D0/
!
END
SUBROUTINE BOND(X,Y,Z,BL,NCAL,PN,IFunc,Iwhole)
!
   IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!
   Parameter(MaxOff=200000,MaxAtm=100,MaxStp=141,MinStp=6)
   COMMON CO(MaxOff),IC(MaxOff),NCENT,NMO,NPRIMS
   COMMON /DIST/ BANGLE(6),RMIN,RMAX,MINR
   COMMON /OFFSET/ ITYPE,ICENT,IMO,IEORB,IE,ICHARG,IXC,IYC,IZC,&
   &IXX, IYY, IZZ,IRR,IR2,IP,IPSI,IGX,IGY,IGZ,IGXX,IGXY,IGXZ,IGYY,&
   &IGYZ,IGZZ,IGXXX,IGXXY,IGXXZ,IGXYY,IGXZZ,IGXYZ,IGYYY,IGYYZ,&
   &IGYZZ,IGZZZ,IGXXXX,IGXXXY,IGXXXZ,IGXXYY,IGXXZZ,IGXYYY,IGXZZZ,&
   &IGXXYZ,IGXYYZ,IGXYZZ,IGYYYY,IGYYYZ,IGYYZZ,IGYZZZ,IGZZZZ,ICofMx
   Common /What/ IWhat
   DIMENSION R1(3,MaxStp),PN(4),PR(3,MaxStp),H(3,3),SG(3,3),&
   &PPN(3),GRHO(3),tmpxyz(3)
   Save Zero,dxyz,pt15,fifty,pt2,one,two,three,fvhund,&
   &pt01,pt001,small
   Data Zero/0.0d0/,dxyz/1.d-3/,pt15/0.15d0/,fifty/50.0d0/,&
   &pt2/0.2d0/,One/1.0d0/,Two/2.0d0/,Three/3.0d0/,&
   &fvhund/500.0d0/,pt01/0.01d0/,pt001/0.001d0/,small/1.d-9/,&
   &Hund/1.d2/
!
   Iwhat=0
   Pi=Dacos(-one)
   BL = Zero
   NCAL = 0
   R1(1,1) = X
   R1(2,1) = Y
   R1(3,1) = Z
   tmpxyz(1)=R1(1,1)
   tmpxyz(2)=R1(2,1)
   tmpxyz(3)=R1(3,1)
   CALL GRDRHO(0,tmpxyz,RHO,GRHO,GRAD,H,SG)
   PR(1,1)=GRHO(1)
   PR(2,1)=GRHO(2)
   PR(3,1)=GRHO(3)
   NCAL = NCAL+1
!
110 NN = INT((RMIN-Pt15)*Fifty)
   IF (NN.LT.MinStp) NN = MinStp
   IF (NN.GT.(Maxstp-1)) NN = MaxStp-1
   DS = (RMIN-Pt15)/DFLOAT(NN)
   CALL DES(R1,PR,DS,NN)
   NCAL = NCAL+NN+NN
   BL = BL+DFLOAT(NN)*DS
   DO 100 I = 1,3
      R1(I,1) = R1(I,NN+1)
      PR(I,1) = PR(I,NN+1)
100 CONTINUE
   IF (RMIN.GT.Pt2) GOTO 110
   PPN(1) = CO(IXC+MINR)
   PPN(2) = CO(IYC+MINR)
   PPN(3) = CO(IZC+MINR)
   BL = BL+RMIN+DXYZ
   IFAIL = 1
   CALL NEWTON(PPN,IFAIL,IFUNC,Iwhole,NITER,1)
   PN(1) = PPN(1)
   PN(2) = PPN(2)
   PN(3) = PPN(3)
   PN(4) = RMIN
130 GR = DSQRT((PN(1)-R1(1,1))**2+(PN(2)-R1(2,1))**2+&
   &(PN(3)-R1(3,1))**2)
   IF (GR .GT. pt01) THEN
      NN = INT((GR-dxyz)*fvhund)
      IF (NN.LT.minstp) NN = minstp
      IF (NN.GT.(maxstp-1)) NN = MaxStp-1
      DS = (GR-dxyz)/DFLOAT(NN)
      CALL DES(R1,PR,DS,NN)
      NCAL = NCAL+NN+NN
      DO 120 I = 1,3
         R1(I,1) = R1(I,NN+1)
         PR(I,1) = PR(I,NN+1)
120   CONTINUE
      GOTO 130
   END IF
!
   BANGLE(4) = one
   BANGLE(5) = DACOS(BANGLE(3))
   IF (DABS(BANGLE(1)) .LT. Small) THEN
      BANGLE(6) = Pi/Two
      IF (BANGLE(2).LT.Zero) BANGLE(6) = Three*BANGLE(6)
   ELSE
      BANGLE(6) = DATAN(BANGLE(2)/BANGLE(1))
   ENDIF
   IF (BANGLE(1).LT.Zero) BANGLE(6) = BANGLE(6)+Pi
   IF(BANGLE(1) .GE. Zero .AND. BANGLE(2) .LT. Zero) BANGLE(6)=&
   &BANGLE(6)+Two*Pi
!
   RETURN
END
DOUBLE PRECISION FUNCTION DASUM(N,DX,INCX)
!
!     TAKES THE SUM OF THE ABSOLUTE VALUES.
!     JACK DONGARRA, LINPACK, 3/11/78.
!
   DOUBLE PRECISION DX(1),DTEMP
   INTEGER I,INCX,M,MP1,N,NINCX
!
   DASUM = 0.0D0
   DTEMP = 0.0D0
   IF(N.LE.0)RETURN
   IF(INCX.EQ.1)GO TO 20
!
!        CODE FOR INCREMENT NOT EQUAL TO 1
!
   NINCX = N*INCX
   DO 10 I = 1,NINCX,INCX
      DTEMP = DTEMP + DABS(DX(I))
10 CONTINUE
   DASUM = DTEMP
   RETURN
!
!        CODE FOR INCREMENT EQUAL TO 1
!
!
!        CLEAN-UP LOOP
!
20 M = MOD(N,6)
   IF( M .EQ. 0 ) GO TO 40
   DO 30 I = 1,M
      DTEMP = DTEMP + DABS(DX(I))
30 CONTINUE
   IF( N .LT. 6 ) GO TO 60
40 MP1 = M + 1
   DO 50 I = MP1,N,6
      DTEMP = DTEMP + DABS(DX(I)) + DABS(DX(I + 1)) + DABS(DX(I + 2))&
      &+ DABS(DX(I + 3)) + DABS(DX(I + 4)) + DABS(DX(I + 5))
50 CONTINUE
60 DASUM = DTEMP
   RETURN
END
SUBROUTINE DES(R1,PR,DS,NN)
!
   IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!
   Parameter (MaxStp=141)
   COMMON /C2/ EPSD,AB(9,9),AM(9,10)
   DIMENSION R1(3,MaxStp),W1(3,9),R(3),W(3),PR(3,MaxStp),&
   &H(3,3), SG(3,3),tmpxyz(3),grho(3)
   Save Zero,One
   Data Zero/0.0d0/,One/1.0d0/
!
!     IF IT IS THE FIRST STEP, START WITH A SINGLE STEP METHOD.
!
   DO 100 I = 1,5
      DO 110 L = 1,3
         W(L) = R1(L,I)
         DO 110 J = 1,I
            G = DSQRT(PR(1,I-J+1)**2+PR(2,I-J+1)**2+PR(3,I-J+1)**2)
            W1(L,J) = PR(L,I-J+1)/G
110   CONTINUE
      CALL MULTI1(W,R1(1,I+1),W1,I,DS,DFLOAT(I)*DS)
      tmpxyz(1)=R1(1,I+1)
      tmpxyz(2)=R1(2,I+1)
      tmpxyz(3)=R1(3,I+1)
      CALL GRDRHO(0,tmpxyz,RHO,GRHO,GRAD,H,SG)
      PR(1,I+1)=GRHO(1)
      PR(2,I+1)=GRHO(2)
      PR(3,I+1)=GRHO(3)
100 CONTINUE
!
!     PERFORM THE REMAINING STEPS WITH A 6 STEP METHOD OF ORDER 7.
!
   DO 130 I = 6,NN
      DO 140 L = 1,3
         W(L) = R1(L,I)
         DO 140 J = 1,6
            G = DSQRT(PR(1,I-J+1)**2+PR(2,I-J+1)**2+PR(3,I-J+1)**2)
            W1(L,J) = PR(L,I-J+1)/G
140   CONTINUE
      CALL MULTI1(W,R1(1,I+1),W1,6,DS,DFLOAT(I)*DS)
      tmpxyz(1)=R1(1,I+1)
      tmpxyz(2)=R1(2,I+1)
      tmpxyz(3)=R1(3,I+1)
      CALL GRDRHO(0,tmpxyz,RHO,GRHO,GRAD,H,SG)
      PR(1,I+1)=GRHO(1)
      PR(2,I+1)=GRHO(2)
      PR(3,I+1)=GRHO(3)
      IF (I .NE. (I/20)*20) GOTO 130
      DO 150 L = 1,3
         W(L) = R1(L,I)
150   CONTINUE
      CALL MULTI1(W,R,W1,5,DS,DFLOAT(I)*DS)
!
!     ESTIMATE THE ERROR.
!
      EPS1 = Zero
      DO 160 L = 1,3
         EPS1 = EPS1+(R(L)-R1(L,I+1))**2
160   CONTINUE
      EPS1 = DSQRT(EPS1)
      RH = DMAX1(One,DSQRT(R1(1,I+1)**2+R1(2,I+1)**2+R1(3,I+1)**2))
      EPSD = DMAX1(EPSD,EPS1/RH)
130 CONTINUE
   RETURN
END
SUBROUTINE NEWTON(R,IFAIL,IFUNC,IWHOLE,NITER,INuc)
!
   IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!
   Parameter(MaxSch=20)
   COMMON /UNITS/ INPT, IOUT, IWFN, IWLP
   Common /What/ IWhat
   Common /Options/ ICut,IPrint,Eps,EpsNuc,Dmp,Dmpnuc
   INTEGER INFO
!     Use LAPACK routine DGESV for solving the Hessian system
   DIMENSION W(3),R1(3),IW(3),XX(2),R(3),SG(3,3),H(3,3)
   Save Zero,pt1,pt05,pt025,One
   Data Zero/0.0d0/,pt1/0.1d0/,pt05/0.05d0/,pt025/0.025d0/,&
   &One/1.0d0/,pt25/0.25d0/
1000 FORMAT(' STEP',3X,'CURRENT COORDINATES ',40X,'|GRAD(Rho)|',/)
1001 FORMAT(' STEP',3X,'CURRENT COORDINATES ',40X,&
   &'|GRAD(DEL**2(Rho))|',/)
1002 FORMAT(' STEP',3X,'CURRENT COORDINATES ',40X,&
   &'|GRAD(G)|',/)
1003 FORMAT(' STEP',3X,'CURRENT COORDINATES ',40X,&
   &'|GRAD(K)|',/)
1004 FORMAT(' STEP',3X,'CURRENT COORDINATES ',40X,&
   &'|GRAD(Vnuc)|',/)
1005 FORMAT(' STEP',3X,'CURRENT COORDINATES ',40X,&
   &'|GRAD(V)|',/)
1010 FORMAT(1X,I4,3X,1P4E18.10)
1020 FORMAT(' NUMBER OF NEWTON-RAPHSON ITERATIONS : ',I4)
1030 FORMAT(' CRITICAL POINT NOT YET FOUND.  CONTINUE SEARCH',&
   &' ? (0=no/1=yes) ',$)
1040 FORMAT(' TRY AGAIN ')
!
   Cutoff=eps
   If(Inuc.eq.1)cutoff=epsnuc
   Damp=Dmp
   If(Inuc.eq.1)Damp=Dmpnuc
!
   IWhat=1
!
   CALL GRDRHO(1,R,RHO,W,GRAD,H,SG)
!
   IS = 0
   If(Iprint.eq.1)Then
      IF (IFAIL .EQ. 0) Then
         If(Iwhole.eq.0)Then
            WRITE (IOUT,1000)
            WRITE (IOUT,1010) IS,R(1),R(2),R(3),GRAD
         Endif
      Endif
   Endif
!
!    BEGIN NEWTON RAPHSON SEARCH
!
99 DO 100 I = 1,MaxSch
      IS = IS + 1
      DO 105 J = 1,3
         R1(J) = W(J)
105   CONTINUE
      CALL DGESV(3,1,H,3,IW,R1,3,INFO)
      IF(INFO.NE.0) THEN
         IFAIL = 1
         GOTO 150
      ENDIF
      DO 110 J = 1,3
         DJ = DABS(R1(J))
         IF (DJ.GT.Damp) R1(J) = Damp*R1(J)/DJ
         R(J) = R(J) - R1(J)
110   CONTINUE
!
      CALL GRDRHO(1,R,RHO,W,GRAD,H,SG)
!
      IF (IFAIL .EQ. 0.and.Iwhole.eq.0.and.iprint.eq.1) Then
         WRITE (IOUT,1010) IS,R(1),R(2),R(3),GRAD
      Endif
!
      IF (GRAD .LE. Cutoff) THEN
         NITER=I
         Goto 150
      END IF
100 CONTINUE
!
!    SHALL WE CONTINUE ?
!
   IF (IFAIL .EQ. 1) Goto 150
!
130 CONTINUE
   IYN=0
   IF(IWHOLE.EQ.0)Then
      WRITE (IOUT,1030)
      READ (INPT,*) IYN
   Endif
   IF (IYN .EQ. 0) THEN
      IFAIL = 1
      Goto 150
   ELSE IF (IYN .EQ. 1) THEN
      GOTO 99
   ELSE
      WRITE (IOUT,1040)
      GOTO 130
   END IF
!
150 Continue
!
   RETURN
END
SUBROUTINE MULTI1(W,R,W1,I,DS,S)
!
   IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!
   COMMON /C2/ EPSD,AB(9,9),AM(9,10)
   DIMENSION W1(3,I),W(3),R(3),R1(3),HESS(3,3),SG(3,3)
!
!     PERFORM A PREDICTOR STEP OF ORDER I.
!
   DO 100 L = 1,3
      H = 0.0D0
      DO 110 J = 1,I
         H = H+AB(I,J)*W1(L,J)
110   CONTINUE
      R(L) = W(L)+H*DS
100 CONTINUE
!
!     PERFORM A CORRECTOR STEP OF ORDER I+1.
!
   CALL GRDRHO(0,R,RHO,R1,Gnorm,HESS,SG)
   DO 120 L = 1,3
      H = AM(I,1)*R1(L)/Gnorm
      DO 130 J = 1,I
         H = H+AM(I,J+1)*W1(L,J)
130   CONTINUE
      R(L) = W(L)+H*DS
120 CONTINUE
   RETURN
END
end module bond
